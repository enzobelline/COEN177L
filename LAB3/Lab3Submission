//3.1
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.1
# Description: This program iterates through child processes that duplicate downstream and upstreams
/**************************
*	pipe()
**************************/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h> 
#include <sys/wait.h> 
//main
int main() {
 	int fds[2];
 	pipe(fds);
	/*child 1 duplicates downstream into stdin */
	if (fork() == 0) {
		dup2(fds[0], 0);
		close(fds[1]);
		execlp("more", "more", 0); 
	}
	/*child 2 duplicates upstream into stdout */
	else if (fork() == 0) {
		dup2(fds[1], 1);
		close(fds[0]);
		execlp("ls", "ls", 0); 
	}
	else {  /*parent closes both ends and wait for children*/
		close(fds[0]);
		close(fds[1]);
		wait(0);
		wait(0); 
	}
} 
//3.2
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.2
# Description: This program iterates through child processes that write downstream and upstreams
/**************************
*   Lab3 - pipe()
**************************/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h> 
#include <string.h>
#include <sys/wait.h> 

// main
int main(int argc,char *argv[]){
   int  fds[2];
   char buff[60];
   int count;
   int i;
   pipe(fds);
   
   if (fork()==0){
       printf("\nWriter on the upstream end of the pipe -> %d arguments \n",argc);
       close(fds[0]);
       for(i=0;i<argc;i++){
           write(fds[1],argv[i],strlen(argv[i]));
       }
       exit(0);
   }
   else if(fork()==0){
       printf("\nReader on the downstream end of the pipe \n");
       close(fds[1]);
       while((count=read(fds[0],buff,60))>0){
           for(i=0;i<count;i++){
               write(1,buff+i,1);
               write(1," ",1);
           }
           printf("\n");
       }
       exit(0);
    }
   else{     
      close(fds[0]);
      close(fds[1]);
      wait(0);
      wait(0);
   }
return 0;
}

//3.3 
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.3
# Description: This program runs "ls" in the upstream and then sends it to the downstream
/**************************
*   Lab3 - pipe()
**************************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h> 
#include <string.h>
#include <sys/wait.h> 

// main
int main(int argc,char *argv[]){
   int  fds[2];
   char buff[60];
   int count;
   int i;
   pipe(fds);
   
   if (fork()==0){
       printf("\nWriter on the upstream end of the pipe -> %d arguments \n",argc);
	//added***************
       dup2(fds[1],1);
       execlp("ls", "ls", 0);
	//
       close(fds[0]);
       for(i=0;i<argc;i++){
           write(fds[1],argv[i],strlen(argv[i]));
       }
       exit(0);
   }
   else if(fork()==0){
       printf("\nReader on the downstream end of the pipe \n");
       close(fds[1]);
       while((count=read(fds[0],buff,60))>0){
           for(i=0;i<count;i++){
               write(1,buff+i,1);
               write(1," ",1);
           }
           printf("\n");
       }
       exit(0);
    }
   else{     
      close(fds[0]);
      close(fds[1]);
      wait(0);
      wait(0);
   }
return 0;
}
//3.4
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.4
# Description: This program incorporates pipe to execute appropriate roots
/**************************
*	pipe()
**************************/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h> 
#include <sys/wait.h> 
//main
int main() {
 	int fds[2];
 	pipe(fds);
	/*child 1 duplicates downstream into stdin */
	if (fork() == 0) {
		dup2(fds[0], 0);
		close(fds[1]);
        	execlp("grep", "grep", "root", 0);
	}
	/*child 2 duplicates upstream into stdout */
	else if (fork() == 0) {
		dup2(fds[1], 1);
		close(fds[0]);
        	execlp("cat", "cat", "/etc/passwd", 0); 
	}
	else {  /*parent closes both ends and wait for children*/
		close(fds[0]);
		close(fds[1]);
		wait(0);
		wait(0); 
	}
}

//3.5
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.5
# Description: This program the producer send a message to memory and then the consumer reads it
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h> 
#include <sys/ipc.h>
#include <sys/errno.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <unistd.h>

int main() {
	key_t sharedKey;
	int queue = msgget(sharedKey, IPC_CREAT | 0644);
        char * sharedBuffer = (char *) shmat(sharedMemory, 0, 0);	
	int sharedMemory = shmget(sharedKey, 1024, IPC_CREAT | 0666);

	//PRODUCER
	if (fork() == 0){ 
		const char *message = "COEN177WINTER2022";	
		strncpy(sharedBuffer, message, strlen(message));

		/* Data is ready. */
		int msgp = 1;
		int msgsnd_return = msgsnd(queue, &msgp, sizeof(msgp), IPC_NOWAIT);
		
		if (msgsnd_return == 0) {
			printf("ProducerMessage. Message: %s \n", message);
		}
		else {
			printf("ERROR: %d\n", errno);
		}
	}
	//CONSUMER
	else if (fork()==0){
		/* Check message status. */
		int message_status = msgrcv(queue, NULL, 0, 0, 0);
		
		/* Read buffer. */
		char message[128];
		strncpy(message, sharedBuffer, sizeof(message));
		
		printf("ConsumerMessage. Message: %s \n", message);
	}
	wait(0);
	wait(0); 
	return 0;
}


//3.6
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.6
# Description: This program creates threads and then prints them
/**************************
*       COEN177: Threads  *
**************************/
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

//The code creates threads and prints the thread # and its corresponding data 
void *go(void *);
#define NTHREADS 10
pthread_t threads[NTHREADS];
int main() {
    int i;
    for (i = 0; i < NTHREADS; i++)  
        pthread_create(&threads[i], NULL, go, &i);
    for (i = 0; i < NTHREADS; i++) {
	printf("Thread #%d returned\n", i);
        pthread_join(threads[i],NULL);
    }
    printf("Main thread done.\n");
    return 0;
}
void *go(void *arg) {
 printf("Thread #%d Iteration %d\n",  (int)pthread_self(), *(int *)arg);
 return 0;
}





//3.7
# Name: Laurence Kim
# Date: 01/28/2022
# Title: Lab3.7
# Description: This program creates threads prints them but in order as the threads are now given a counter argument
/**************************
*       COEN177: Threads  *
**************************/
// Description: fixes counter by giving each thread's argument its own memory.

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *go(void *);
#define NTHREADS 10
pthread_t threads[NTHREADS];
int main() {
    int numbers[NTHREADS];
    int i;
    for (i = 0; i < NTHREADS; i++) {
	numbers[i] = i; 
        pthread_create(&threads[i], NULL, go, &numbers[i]);
    }
    for (i = 0; i < NTHREADS; i++) {
    printf("Thread #%d returned\n", i);
        pthread_join(threads[i],NULL);
    }
    printf("Main thread done.\n");
    return 0;
}
void *go(void *arg) {
 printf("Thread #%d Iteration %d\n",  (int)pthread_self(), *(int *)arg);
 return 0;
}


